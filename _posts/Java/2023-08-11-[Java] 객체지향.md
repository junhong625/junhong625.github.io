---
layout : post
title : '[Java] 객체지향'
subtitle : '[Java] 객체지향'
gh-repo: junhong625/Study
gh-badge: [star, fork, follow]
tags : [CS, Java, Study]
comments: true
---

## 캡슐화

> 연관된 목적을 가지는 변수와 메서드를 하나의 클래스로 묶어 외부에서의 무분별한 접근을 막는 것, 정보를 은닉하기 위함
> 

→ 자바의 접근제어자, getter, setter

```java
public class Person {
	
	private int age;
	
	public int getAge() {
		return age;
	}
}

public class HelloWorld {
	public static void main(String[] args) {
		Person p1 = new Person();
		System.out.println(p1.getAge() + "살 입니다.");
	}
}
```

## 상속화

> 부모클래스에서 정의된 변수, 메서드들을 자식클래스에서 사용하는것
코드의 재사용성을 높이기 위함
> 

→ extends, implements

→ 추상 클래스와 인터페이스

추상클래스 **abstract class**

```java
public abstract class AbstractPhone {
	
	int intVal; // 일반 변수

	public void alarm() { // 일반 메서드
		System.out.println("띠리리리리리링");
	}
	
	public abstract void bell(); // 추상 메서드
}

// 상속 //

public class Phone1 extends AbstractPhone {
	
	@Override
	public void bell() {
		System.out.println("또로로로로로로롱");
	}
	
	public static void main(String[] args) {
		Phone1 phone1 = new Phone1();
		phone1.alarm(); // 띠리리리리리링
		phone1.bell(); // 또로로로로로로롱
	}
}
```

인터페이스 **interface**

원래는 모든 메소드가 추상 메소드여야 했지만 자바 8부터 default 메소드 구현가능

```java
public interface InterfacePhone {
	
	int intVal = 32; // public static final int intVal = 32, 상수 생략가능
	
	public void alarm(); // 추상 메서드
	public abstract void bell(); // 추상 메서드

}

// 상속 //

public class Phone2 implements InterfacePhone {
	
	@Override
	public void alarm() {
		System.out.println("띠라띠라띠라디라띠라");
	}
	
	@Override
	public void bell() {
		System.out.println("또로로로멘또롱");
	}
	
	public static void main(String[] args) {
		Phone2 phone2 = new Phone2();
		phone2.alarm(); // 띠라띠라띠라디라띠라
		phone2.bell(); // 또로로로멘또롱
		
		System.out.println(Phone2.intVal); // 32
	}
}
```

<aside>
❓ 인터페이스는 왜 존재하는 걸까?
그냥 추상클래스에서 모두 다 추상메서드로 잡으면 되는 거 아닌가?

</aside>

목적의 차이

- 추상클래스 : 추상 클래스를 상속받아 그 기능을 확장 시키기 위함
- 인터페이스 : 함수의 껍데기, 함수의 구현을 강제 함으로써 클래스의 설계 또는 표준화를 유도 할 수 있음

**extends : 추상클래스를 단일 상속**

**implements : 인터페이스를 다중 상속**

<aside>
💡 자바에서 클래스의 다중상속은 불가능하다.

```java
public abstract class AbstractClass1 {

	public void output1() {
		System.out.println("AbstractClass1의 출력물입니다.");
	}

	public abstract void output2();
}

public abstract class AbstractClass2 {

	public void output1() {
		System.out.println("AbstractClass2의 출력물입니다.");
	}

	public abstract void output2();

```

```java

public interface Interface1 {
	
	public void output1();
	public abstract void output2();
}
 

public interface Interface2 {
	
	public void output1();
	public abstract void output2();
}
 
public class MainClass implements Interface1, Interface2 {
	
	@Override
	public void output1() {
		System.out.println("output1의 출력물입니다.");
	}
	
	@Override
	public void output2() {
		System.out.println("output2의 출력물입니다.");
	}
	
	public static void main(String[] args) {
		MainClass mainClass = new MainClass();
		
		mainClass.output1(); // output1의 출력물입니다.
		mainClass.output2(); // output2의 출력물입니다.
	}
}

```

</aside>

## 다형성

> 각요소들이 여러가지 자료형으로 표현될 수 있는것
상위클래스가 동일한 메세지로 하위클래스들을 서로 다르게 동작시킴
> 

```java
class People{
    public void printInfo() {
        System.out.println("나는 사람입니다.");
    }
}

class Man extends People{}
class Woman extends People{}

public class Test {
 
    public static void main(String[] args) {
        Man man=new Man();
        Woman woman=new Woman();
         
        man.printInfo(); // 나는 사람입니다.
        woman.printInfo(); // 나는 사람입니다.
    }
}
```

ㅇㅈ
**Man은 People이다. (남자는 사람이다.)
Woman은 People이다. (여자는 사람이다.)**

ㄴㅇㅈ
**People은 Man이다. (사람은 남자이다.)
People은 Woman이다. (사람은 여자이다.)**

<aside>
💡 **Man은 People로 표현할 수 있고, Woman도 People로 표현할 수 있다**
Man과 Woman은 People이기 때문에 People이라는 자료형으로 받을 수 있다.

</aside>

**오버라이딩과 추가 함수**

```java
class Man extends People{
    @Override
    public void printInfo() {
        super.printInfo();
        System.out.println("그리고 나는 남자입니다.");
    }
		
		public void enlist() {
        System.out.println("내일 군대를 갑니다.");
        System.out.println("충성!");
    }
}

public class Test {
 
    public static void main(String[] args) {
        People people=new Man();
        people.printInfo();
        ((Man)people).enlist();
    }
}
```

<aside>
💡 캐스팅
People은 자신을 상속한 클래스 중에서 어떤 매소드를 만들지, 어떤 멤버 변수를 만들어낼지 미리 알아낼 수 없기 때문에 그 메소드가 있는 객체로 직접 캐스팅해주어서 매소드를 사용해야한다.

</aside>

![Untitled](https://github.com/junhong625/Cigma/assets/83000975/21b88b03-362a-48e7-88ba-a343adde437e)

자료형은 People 로 했지만 new 키워드를 이용해 Man 객체를 만든 것.
Man 으로 형변환이 가능함.

## 추상화

> 공통된 특징을 묶어 하나의 클래스로 정의하는 것
> 

→ 추상클래스와 인터페이스

---
참조  
    [[Java] 자바기초 - 객체지향(OOP) - 상속화(Inheritance)](https://jforj.tistory.com/21)  
    [[Java] 자바기초 - 추상클래스와 인터페이스(abstract/interface)](https://jforj.tistory.com/17)  
    [[JAVA] 자바 다형성(Polymorphism) 개념부터 응용 쉬운 설명](https://reakwon.tistory.com/48)