---
layout : post
title : '[SQLD] 과목 1 - 데이터 모델링의 이해 요약'
subtitle : '[SQLD] 요약 정리'
gh-repo: junhong625/Study
gh-badge: [star, fork, follow]
tags : [SQL, Study]
comments: true
---

# 과목 1 - 데이터 모델링의 이해
- - - 

## 데이터 모델링
- 데이터 모델링 정의
    - 현실 데이터에 대해 약속된 표기법에 의해 표현
    - DB 구축을 위한 분석 및 설계의 과정
<br>
<br>

- 데이터 모델링 특징
    - **추상화** : 형식에 맞춰 간략하게 표현
    - **단순화** : 이해하기 쉽게 표현
    - **명확성** : 명확하게 한 가지 의미를 갖도록 표현
<br>
<br>

- 데이터 모델링유의점
    - **중복** : 데이터 중복성 최소화
    - **비유연성** : 데이터 정의와 프로세스를 분리해 DB에 큰 변화를 일으킬 가능성을 최소화
    - **비일관성** : 데이터 간의 연관관계 정의
<br>
<br>

- 데이터 모델링 단계
    1. **개념적 모델링** : 추상화⬆, 업무 중심적, 포괄적, 개념적 ERD 작성 단계
    2. **논리적 모델링** : Key, 속성, 관계 등을 정확히 표현, 정규화를 통해 재사용성⬆︎
    3. **물리적 모델링** : 성능, 저장 등 물리적 설계 단계
<br>
<br>

- 데이터 모델링 관점 
    1. **데이터 관점** : 업무가 어떤 데이터와 관련이 있는지, 데이터 간의 관계는 무엇이지에 대한 모델링
    2. **프로세스 관점** : 업무가 실제하고 있는 일은 무엇인지, 무엇을 해야하는지에 대한 모델링
    3. **데이터와 프로세스의 상관관점** : 업무 처리 방법에 따라 데이터는 어떤 영향을 받는지 모델링
<br>
<br>

- 스키마 3단계 
    1. **외부 스키마** : 사용자 관점, 응용 프로그래머가 데이터 베이스에 접근하는 View를 표현
    2. **개념 스키마** : 설계자 관점, 모든 통합 관점, DB 규칙과 구조를 표현
    3. **내부 스키마** : 개발자 관점, 물리적 장치 입장, 레코드 구조, 인덱스 등을 표현
<br>
<br>

- ERD 표기법

<img height=200 src="https://user-images.githubusercontent.com/83000975/170675810-05ded7d9-7991-4237-b8bd-cc0498166de9.gif">

<img height=200 src="https://user-images.githubusercontent.com/83000975/170676378-09f2c317-a467-47db-af77-797fb02f2452.png">
<br>
<br>

- ERD 작성 순서
    1. 엔티티 그리기
    2. 엔티티 배치
    3. 엔티티간 관계 설정
    4. 관계명 기술
    5. 관계의 참여도 기술
    6. 관계의 필수 여부 기술
<br>

## 엔티티
- 정의 : 업무에서 관리하는 데이터 집합
<br>

- 엔티티 특징 
    - **유일한 식별자**가 있어야 한다. 
    - 인스턴스가 2개 이상 있어야 한다.
    - 속성을 2개 이상 가지고 있어야 한다.
    - 하나의 속성은 하나의 속성값
    - 다른 엔터티와 최소 한 개 이상의 관계
    - 업무에서 관리 되어야할 집합
<br>

- 엔티티 분류 
    - 유무형 분류
        - 유형 엔티티 : 물리적 형태(사원, 물품)
        - 사건 엔티티 : 업무 수행에 따라 발생(주문, 창구)
        - 개념 엔티티 : 관리해야할 개념적 정보(부서, 장소)
<br>

    - 발생 시점 분류
        - 기본/키 엔티티 : 독립적으로 생산되는 엔티티(사원, 부서)
        - 중심 엔티티 : 업무에 중요한 역할을 하는 엔티티(주문, 접수)
        - 행위 엔티티 : 두 개 이상의 부모 엔티티로부터 발생(주문내역, 계약진행)
<br>

- 엔티티 명명 규칙
    - 협업 용어를 사용
    - 약어 사용 X
    - 단수명사를 사용
    - 고유어가 되어야 한다.
    - 생성 의미대로 이름 부여
<br>

## 속성
- 정의 : 엔티티가 가지는 항목이며 더 이상 분리되지 않는 데이터 단위
<br>

- 속성 분류
    1. 엔티티 구성에 따른 분류
        - **PK 속성** : 엔티티를 식별할 수 있는 속성
        - **FK 속성** : 다른 엔티티와의 관계에 포함된 속성
        - **일반 속성** : PK, FK를 제외한 나머지 속성
        <br>

    2. 분해 여부에 따른 분류
        - **복합 속성** : 여러 개의 의미를 지닌 속성
        - **단일 속성** : 하나의 의미를 지닌 속성
        - **다중값 속성** : 하나의 속성에 여러개의 값을 가지는 경우(관계로 연결 필요)
        <br>

    3. 특성에 따른 분류
        - **기본 속성** : 업무로 부터 추출한 모든 속성
        - **설계 속성** : 모델링, 업무 규칙화를 위해 새로 생성/변형하어 정의하는 속성
        - **파생 속성** : 다른 속성의 영향을 받아 발생
<br>

## 관계 
- 정의 : 엔티티 간의 관련성
<br>

- 관계의 유의점
    - 두 개의 엔티티 사이에 연관 규칙 존재 유무
    - 업무기술서, 장표에 관계 연결을 가능하게 하는 동사 유무
    - 업무기술서, 장표에 관계 연결 규칙 서술 유무
    - 두 개의 엔티티 사이에 정보 조합이 발생 유무
<br>

- 관계의 분류
    - **존재에 의한 관계** : 두 엔티티의 존재 여부에 대한 관계(ex: 사원이 부서에 항상 속해있다.)
    - **행위에 의한 관계** : 두 엔티티가 행위의 관련성에 대한 관계(ex: 주문은 고객이 주문을 할때 발생)
<br>

- 관계의 표기법
    - **1대1 관계** : 서로가 속성 하나씩만을 가지는 관계
    - **1대N 관계** : A 엔티티는 B 엔티티의 속성 하나를 가질 수 있고 B 엔티티는 A 엔티티의 속성 여러개를 가지는 관계
    - **N대N 관계** : 서로 여러개의 속성을 가지는 관계
<br>

## 식별자
- 정의 : 데이터를 구분해주는 논리적인 이름
<br>

* **식별자와 키는 같다?** : 
    - 식별자는 업무적인 관점 ➔ **논리적 데이터 모델링 관점** 
    - 키는 데이터베이스 관점 ➔ **물리적 데이터 모델링 관점**
    - 즉, 식별자와 키는 같지 않다.
<br>

* 키 간단히 분류
> **후보키(Candidate Key)** : **유일성**과 **최소성**을 만족하는 키  
> **기본키(Primary Key)** : 후보키 중 선정한 하나의 키  
> **대체키(Alternate Key)** : 후보키 중 기본키를 제외한 나머지 키  
> **슈퍼키(Super Key)** : **유일성**은 만족하나 **최소성**은 만족하지 못하는 키  

<br>

- 식별자 특징
    - **유일성** : 식별자에 의해 엔티티 내에 모든 인스턴스들은 유일하게 구분되어야 함
    - **최소성** : 식별자를 구분하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함
    - **불변성** : 식별자가 지정되면 그 식별자의 값은 변하지 않아야 함
    - **존재성** : 식별자가 지정되면 반드시 값이 존재해야 함
<br>

- 식별자 분류
    - 대표성 여부에 따른 분류
        - **주식별자** : **유일성**과 **최소성**을 만족하면서 엔티티를 대표하는 식별자이며 타 엔티티와 참조관계 가능
        - **보조식별자** : **유일성**과 **최소성**을 만족하지만 엔티티를 대표하지 않아 타 엔티티와 참조관계 불가능
    <br>
    
    - 자가 생성 여부에 따른 분류
        - **내부식별자** : 엔티티 내부에서 스스로 만들어지는 식별자
        - **외부식별자** : 타 엔티티와의 관계를 통해 타 엔티티로부터 받아오는 식별자
    <br>

    - 속성 수에 따른 분류
        - **단일식별자** : 하나의 속성으로 구성된 식별자
        - **복합식별자** : 두개 이상의 속성으로 구성된 식별자
    <br>

    - 대체 여부에 따른 분류
        - **본질식별자** : 업무에 의해 자연스레 생성되는 식별자
        - **인조식별자** : 업무에 의해 자연스레 생성되지 않고 인위적으로 만든 식별자
<br>

## 데이터 모델과 성능
- 성능 데이터 모델링: 데이터베이스 성능향상을 목적으로 설계단계의 데이터 모델링 때부터 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것
    - 성능 데이터 모델링 순서
        1. 데이터 모델링 시 정규화를 정확하게 수행
        2. DB 용량산정 수행
        3. DB에 발생되는 트랜잭션 유형 파악
        4. 용량과 트랜잭션의 유형에 따라 반정규화 수행
        5. 이력모델의 조정, PK/FK조정, 슈퍼타입/서브타입 조정 등 수행
        6. 성능관점에서 데이터 모델 검증
- Optimizer : 가장 효율적인 방법으로 SQL을 수행할 최적화 경로를 생성해주는 DBMS의 핵심엔진

|항목|규칙 기반 옵티마이저(RBO)|비용 기반 옵티마이저(CBO)|
|:--|:--|:--|
|개념|사전에 정의된 규칙 기반|최소 비용 계산 실행 계획 수립|
|기준|실행우선 순위|액세스 비용(cost)|
|인덱스|존재 시 가장 우선 사용|cost 기준|
|성능|사용자 숙련도|옵티마이저 예측 성능|
|장점|판단이 매우 규칙적(실행 예상 가능)|통계 정보를 통한 현실 요소 적용|
|단점|예측 통계 정보 요소 무시|최소 성능 보장 계획의 에측 제어 어려움|

- 정규화 : 무결성을 유지하고 논리 데이터 모델링의 목적인 정확성, 일관성, 단순성, 비 중복성, 안정성을 만족시키는 것
    - 정규화 방법
        - 제1 정규화 : 테이블의 속성이 원자값(Atomic Value, 하나의 값)을 갖도록 테이블을 분해하는 것
        - 제2 정규화 : 제1 정규화를 진행한 테이블에 대해 **완전 함수 종속**을 만족하도록 테이블을 분해하는 것
            - **완전 함수 종속** : 기본키의 부분집합이 결정자가 되어선 안된다.
        - 제3 정규화 : 제2 정규화를 진행한 테이블에 대해 **이행적 종속**을 없애도록 테이블을 분해하는 것
            - **이행적 종속** : `A -> B`, `B -> C`가 성립할 때 `A -> C`가 성립되는 것
        - BCNF 정규화 : 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것
    - 이상현상(Anomaly)
        - 삽입 이상 : 데이터를 삽입할 때 원하지 않은 값도 함께 삽입되는 현상
        - 삭제 이상 : 튜플을 삭제할 때 연쇄삭제로 인해 정보 손실이 일어나는 현상
        - 갱신 이상 : 튜플의 속성값을 갱신할 때 일부 정보만 갱신되어 정보의 모순이 발생하는 현상
    - 성능 
        - SELECT : JOIN으로 인해 성능 down
        - INSERT, UPDATE : 성능 down
<br>

- 반정규화 : 성능을 향상시키기 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정(데이터 무결성을 해친다)
    - 반정규화 대상조사 : 대량 범위처리 빈도 수, 범위처리 빈도 수, 통계 처리 여부
    - 다른 방법 검토 : 응용 시스템 변경, 클러스터링/인덱스 처리, 뷰 테이블 처리
    - 반정규화 적용
        - 테이블 반정규화
            - 병합 : 1:1 병합, 1:N 병합, 슈퍼/서브 병합
            - 분할 : 수직 분할, 수평 분할
            - 추가 : 중복 테이블 추가, 통계 테이블 추가, 이력 테이블 추가, 부분 테이블 추가
        - 속성 반정규화
            - 파생 컬럼 추가
            - 중복 컬럼 추가
            - 이력 테이블 컬럼 추가
            - PK에 의한 컬럼 추가
            - 응용시스템 오작동을 위한 임시칼럼 추가
        - 관계 반정규화
            - 중복 관계 추가

- 대량 데이터 따른 성능
    - Row migration : update 시 공간 부족으로 인해 발생
        - 새로운 데이터를 다른 블록에 저장 후 기존 공간에는 새로운 데이터를 가리키는 포인터 생성
    - Row chaining : 저장을 할 떄 공간 부족으로 인해 발생
        - 데이터가 나뉘어져 여러 블록에 저장