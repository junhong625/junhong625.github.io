---
layout : post
title : '[빅데이터를 지탱하는 기술] 4-2 [성능x신뢰성] 메시지 배송의 트레이드 오프'
subtitle : '[빅데이터를 지탱하는 기술] 정리'
gh-repo: junhong625/Study
gh-badge: [star, fork, follow]
tags : [빅데이터를 지탱하는 기술, Study]
comments: true
---

# 4-2 [성능x신뢰성] 메시지 배송의 트레이드 오프
- - - 

## 메시지 브로커 - 스토리지의 성능 문제를 해결하는 중간층의 설치
- 메시지 배송에 의해 보내진 데이터를 분산 스토리지에 저장할 때는 주의가 필요하다.
- 외부에서 들어오는 메시지의 양을 제어할 수 없기 때문에 급격한 데이터양 증가에 대응하는 것은 쉬운 일이 아니다.
- 분산 스토리지에 직접 메시지를 기록하면 제어가 어려워 성능 한계에 도달하기 쉬워지는데 이에 대응하기 위해 만들어진 것이 `메시지 브로커`이다.
    - `메시지 브로커(message broker)` : 데이터를 일시적으로 축적하여 쓰기 속도를 안정화시키는 중산층
- 오픈 소스 : Apache Kafka
- 클라우드 서비스 : Amazon Kinesis
<br>
<br>

### 1) 푸쉬 형과 풀 형 - 확장성 향상과 파일 사이즈의 적정화
<img height=400 src="https://user-images.githubusercontent.com/83000975/167759388-0536162a-5556-490b-a1ae-3906e826c455.jpeg">
<sub><b>[푸쉬 형과 풀 형의 메시지 전송]</b></sub>

- `푸시(push)` 형 : 송신 측의 제어로 데이터를 보내는 방식
    - 일정한 빈도로 꺼낸 데이터를 분산 스토리지에 기록하여 성능 문제를 피할 수 있다.
- `풀(pull)` 형 : 수신 측의 주도로 데이터를 가져오는 방식
    - 일정한 간격으로 데이터를 취함으로써 파일 사이즈 적정화에 도움이 된다.
- **메시지 브로커는 데이터의 쓰기 속도를 조정하기 위한 완충 부분이며, 푸쉬 형에서 풀 형으로 메시지 배송의 타이밍을 변환한다.**
- `생산자(producer)` : 메시지 브로커에 데이터를 넣는(push) 것
- `소비자(consumer)` : 메시지 브로커에서 데이터를 꺼내오는(pull) 것
- 메시지 브로커의 특징 : 
    1. 높은 빈도로 데이터를 쓰는 것에 **최적화**
    2. 여러 대의 노드에 부하 분산함으로써 성능을 끌어올릴 수 있는 **뛰어난 확장성**
<br>
<br>

### 2) 메시지 라우팅
- `스트림 처리(stream processing)` : 짧은 간격으로 차례대로 데이터를 꺼내서 처리하는 방식
- `메시지 라우팅(message routing)` : 메시지 브로커에 써넣은 데이터를 복수의 다른 소비자에서 읽어 들이고 이를 통해 메시지가 복사되어 데이터를 여러 경로로 분기시키는 것
    - 메시지 일부를 실시간 장애 감지를 사용하면서 같은 메시지를 장기적인 데이터 분석을 위한 분산 스토리지에 저장하는 것도 가능하다.
<br>
<br>

## 메시지 배송을 확실하게 실시하는 것은 어렵다 - 신뢰성 문제와 세 가지 설계 방식
- 메시지 배송에서 성능 문제 외에도 피할 수 없는 것이 **신뢰성(reliability)**이다.
- 신뢰성 문제를 해결하기 위해 세 가지 설계 방식 중 하나를 보장하도록 설계된다.
    1. **at most once -> 메시지는 한 번만 전송된다. 그러나 도중에 전송에 실패해서 사라질 가능성이 있다(결손 발생).**
    2. **exactly once -> 메시지는 손실되거나 중복 없이 한 번만 전달된다.**
    3. **at least once -> 메시지는 확실히 전달된다. 단, 같은 것이 여러 번 전달될 가능성이 있다(중복).**
<br>
<br>

### 1) at most once
- **메시지는 한 번만 전송된다. 그러나 도중에 전송에 실패해서 사라질 가능성이 있다(결손 발생).**
- 무슨 일이 일어나도 절대로 메시지를 다시 보내지 않는다.
- 대부분의 경우 데이터의 결손을 피하고자 오류가 발생 시 **재전송(retransmission)**이 이루어지는데 이러한 시스템에서는 **at most once**를 보장할 수 없다.
<br>
<br>

### 2) exactly once
- **메시지는 손실되거나 중복 없이 한 번만 전달된다.**
- `코디네이터`가 있어야 **exactly once**가 가능하다.
    - `코디네이터(cordinator)` : 네트워크 상에서 분단된 두 개의 노드가 있을 때 양 쪽의 통신 내용을 중계하는 역할을 한다.
- 그러나 `코디네이터`가 있어도 두 가지 문제점이 있다.
    1. 분산 시스템에서는 `코디네이터`가 항상 존재한다고 가정할 수 없다. 
        - 통신이 끊기거나 코디네이터 자신이 정지되는 경우가 있다.
        - 이때마다 시스템을 멈출 수 없기 때문에 코디네이터 부재의 경우에 어떻게 할 것인가 `합의(consensus)` 하게 된다.
        - 이것은 분산 시스템 설계에 있어서 어려운 문제 중의 하나이다.
    2. `코디네이터`의 판단에만 따르고 있으면 시간이 너무 소요된다.
- 이러한 이유 때문에 메시지 배송 시스템에서는 코디네이터를 도입하지 않고 **exactly once**가 아닌 **at least once**를 선택해 메시지가 중복될 가능성을 고려하여 시스템을 구축한다.
<br>
<br>

### 3) at least once - 중복 제거는 사용자에게 맡긴다.
- **메시지는 확실히 전달된다. 단, 같은 것이 여러 번 전달될 가능성이 있다(중복).**
- **al least once**에서는 **deduplication(중복 제거)** 구조를 만들어둬 가령 메시지가 재전송되어도 그것을 없앨 수 있도록 해야한다.
- TCP/IP에 의한 네트워크 통신은 **ack**플래그를 도입하여 **at least once**를 실현한다.
    - TCP 패킷에서는 시퀀스 번호가 포함되어 있어 이걸 이용하여 중복 제거가 이루어진다.
<br>

- 메시지 배송의 시스템은 항상 아래의 문제점들을 갖고 있다.
    - 중앙에 코디네이터가 존재하지 않는 한 **exactly once**는 실현되지 못하고 **at most once, at least once**로 전송이 이루어진다.
    - **at most once, at least once**는 중복 제거를 하지 않는 한 메시지의 중복이 발생할 수 있다.
    - 대부분의 메시지 배송 시스템은 **at least once**를 보장하지만 중복 제거는 사용자에게 맡기고 있어 TCP/IP처럼 자동으로 중복을 제거해주지 않는다.

|소프트웨어|신뢰성|
|:--|:--|
|Apache Flume|'at least once'를 보장|
|Apache Kafka|'at least once'를 보장|
|Logstash|'at least once'를 보장(2.0 이후)|
|Fluentd|옵션으로 'at least once'를 보장(0.12 이후)|

<sub><b>[메시지 배송에 사용되는 오픈 소스 소프트웨어의 신뢰성]</b></sub>
<br>
<br>

## 중복 제거는 높은 비용의 오퍼레이션
- 메시지의 중복을 제거하기 위해서는 과거에 받은 것인지에 대한 여부를 판정하기 위한 대안으로 2가지가 있다.
    1. 오프셋을 이용한 중복 제거
    2. 고유 ID에 의한 중복 제거
<br>
<br>

### 1) 오프셋을 이용한 중복 제거
- **오프셋** : 파일의 시작 위치
- 파일 전송의 사고방식과 비슷해 메시지가 중복되어도 같은 장소의 같은 파일을 덮어쓸 뿐이므로 문제 되지 않는다.
- 시스템에 따라 **at least once**가 보장되어 있다면 언젠가는 파일이 재구성되어 데이터 전송이 완료된다.
- 벌크 형의 데이터 전송과 같이 데이터양이 고정된 경우에는 잘 작동한다.(**벌크 형 데이터 전송에 적합**)
<br>
<br>

### 2) 고유 ID에 의한 중복 제거
- 모든 메시지에 **UUID(Universally Unique IDentifier)**등의 고유 ID를 지정한다.
- 폭발적으로 늘어나는 ID를 어떻게 관리하느냐가 관건이다.
    - 현실적인 방법으로 최근에 받은 ID에 한해서만 기억해두고 그보다 늦게 온 메시지의 중복은 허용한다.
- 일시적인 통신 오류로 인해 발생하는 중복만 제거하면 99%의 신뢰성을 달성할 수 있다.
- 스트리밍 형의 메시지 배송에서 자주 사용된다.
<br>
<br>

### 3) 종단간(End to End)의 신뢰성
- 메시지에 있어서 **성능**과 **신뢰성**은 `트레이드 오프`의 관계에 있어 한쪽을 우선하면 다른 한쪽이 희생된다.
    - `트레이드 오프(trade off)` : 하나가 증가하면 다른 하나가 무조건 감소한다.
- 빅데이터의 경우 종종 신뢰성보다 성능 쪽이 중시된다.
    - 따라서, 중간 경로에 **at least once**를 보장하는 한편 **중복을 제거 하지 않는 것**이 표준적이다.
- 신뢰성이 높은 메시지 배송을 실현하려면 중간 경로를 모두 **at least once**로 통일한 후 클라이언트 상에서 모든 메시지에 고유 ID를 포함하고 경로의 마지막에서 중복 제거를 실행해야 한다.
<br>
<br>

### 4) 고유 ID를 사용한 중복 제거의 방법 - NoSQL 데이터베이스, SQL
- 고유 ID를 사용하여 중복 제거하는 대표적인 두 가지 방법
    1. 분산 스토리지로 **NoSQL 데이터베이스**를 이용하는 것
        - **Cassandra, Elasticsearch** 등은 데이터를 쓸 때 고유 ID를 지정하는 특성이 있어 중복이 발생하면 동일 ID 데이터를 덮어쓰며 중복 제거가 실현된다.
    2. Hive같은 배치형 쿼리엔진에서 SQL로 중복을 제거하는 것
        - Group by, Distinct 를 사용하여 중복을 제거할 수 있다.
<br>
<br>

## 데이터 수집의 파이프라인 - 장기적인 데이터 분석에 적합한 스토리지
- `데이터 수집의 파이프라인` : 데이터를 수집 -> 데이터 전송(스트리밍 형, 벌크 형) -> 분산 스토리지에 저장 -> 중복 제거 -> 데이터 구조화 -> 열 지향 스토리지로 변환
- 4-1장부터 지금까지 설명한 일련의 프로세스를 거친 다음, 마지막으로 데이터를 구조화해서 열 지향 스토리지로 변환함으로써 장기간의 데이터 분석에 적합한 스토리지가 완성된다.
<img height=400 src="https://user-images.githubusercontent.com/83000975/167834136-4198ce3a-9410-4bcf-b789-64d8bc459264.jpeg">
<sub><b>[데이터 파이프라인 일례(스트리밍 형)]</b></sub>

- 실무에서는 요구 사항에 맞춰 시스템을 조합하여 파이프라인을 구성
    - 쓰기 성능에 불안감이 없다면 메시지 브로커 없이 클라이언트나 프런트엔드에서 NoSQL DB에 직접 데이터를 쓴다.
    - 중복이 허용되면 중복 제거 생략할 수 있다.
    - 데이터 집계에 쿼리 엔진을 사용하는 경우, 구조화된 데이터를 열지향 스토리지 형식으로 객체 스토리지에 저장한다.
<br>
<br>

### 중복을 고려한 시스템 설계 - 빅데이터 시스템에 있어서의 '중복'에 대한 사고방식
- 스트리밍 형의 메시지 배송에서는 중간에 중복 제거를 도입하지 않는 한 항상 중복의 가능성이 있다.
- 하지만 빅데이터 시스템은 매우 높은 성능을 요구하기 때문에 트레이드 오프 관계로 인해 신뢰성이 낮은 부분(아주 작은 중복)은 무시하는 경향이 있다.
- 실제로 불안정한 모바일 회선을 제외하고 데이터 센터와 같은 안정된 회선은 99% 이상의 신뢰성을 확보할 가능성이 높기에 문제가 되지 않는다.
    - **중복이 있어도 문제가 되지 않는 시스템**으로 설계를 추천
> [메시지 브로커와 신뢰성]
> - 메시지의 **중복**과 **결손**은 확률이 아닌 설계상의 트레이드 오프로 인해 발생하는 것이다.
> - 즉, 시스템이 안정적으로 움직이고 있는 한 발생하지 않으므로 신뢰성을 높이기 위해 가능한 한 간섭을 일으키지 않는 것이 중요하다.
> - 프런트 엔드에서 메시지 브로커에 이르는 흐름은 안정된 기록이 가능하도록 확장성 있는 구현을 선택하는 것이 좋다.
> - 메시지 브로커를 사용하면 쓰기 성능 향상과 후속의 처리를 안정화하는데 도움이 된다.
> - 하지만 메시지 브로커에서 자체적으로 장애가 발생하거나 중복이 발생할 가능성도 있으니 이러한 부분에 유의하면서 **성능**과 **신뢰성**을 양립할 필요가 있다.
